#+title: Dockerenv
Dockerizing undockerized "not pure python" app

* Что это
Изоляция *бэкенда большой системы со сложными зависимостями* от других проектов, сервисов и ОС *для разработки*.
Это заготовка, скелет для контейнеризации разработки на рабочем месте разработчика: позволяет ему взять типовой python-проект, поправить конфигурацию и запустить python-проект в виртуальном окружении включая необходимые ему сервисы и пакеты.

* Зачем это
Хотим получить:
1. Воспроизводимость результатов разработки
2. Отделение devops от разработки
3. Изоляция разработки проекта от окружения

Предлагается принцип /"работает == работает в докер-контейнере"/.

** Изоляция от окружения
Достаточно большой бэкенд для запуска требует сложной настройки, установки и сборки дополнительных пакетов, запуска дополнительных сервисов. Для работы требуются особые зависимости.

Если это какая-то внутренняя сырая разработка, то лежащим рядом с кодом скриптам  запуска нет доверия, они не протестированы как следует: могут делать странные вещи (например, ставить pycharm), работать только на какой-то конкретной ОС конкретной версии (например, "скрипт запуска на Ubuntu 22.04", а у вас Ubuntu 24.04)

В принципе в мире Python есть уже инструменты изоляции разработки от окружения: virtualenv фиксирует отдельные версии пакетов, pyenv позволяет менять версии Python.

Однако остается еще уровень сервисов (postgresql, opensearch, redis, manticore etc) и пакетов - пакеты для конретного проекта (например, простейший https://github.com/django-ve/django-helloworld требует установки дополнительных пакетов), конкретные версии пакетов для работы библиотек, самостоятельная сборка пакетов (GDAL какой-то специальной версии, например).

** Разделение devops и разработчиков
Явно описанная архитектура системы в виде файла compose (docker compose - язык описания архитектуры приложения) позволяет эффективно отделить разработку бэкенда от деплоя: devops понимает как устроен бэкенд, понимает как его запустить, может планировать свой способ деплоя в прод и разрабатывать его в отдельном репозитории.
** Воспроизводимость результатов разработки
Явно прописанная схема сборки упрощает тестирование и онбординг.

* Как это
** Пример
Рассмотрим на примере простого проекта https://github.com/django-ve/django-helloworld .
Находясь в корне нашего проекта:
#+begin_src sh
git clone https://github.com/django-ve/django-helloworld.git
cd django-helloworld
#+end_src
Создаем =./build.sh=, вставляем пакеты из инструкции /django-helloworld/:
#+begin_src sh
#!/usr/bin/env sh
apt update
apt install -y python3-dev python3-pip python3-virtualenv sqlitebrowser
#+end_src
Ставим dockerenv:
#+begin_src sh
git clone https://github.com/vasily-fedorov/dockerenv.git
cd dockerenv
#+end_src
Редактируем .env:
#+begin_src shell
PYTHON_VERSION=3.11.10
IMAGE=ubuntu:22.04
BUILD_ROOT_SH=build.sh
BUILD_USER_SH=""
CMD="python manage.py runserver 0.0.0.0:8000"
#CMD="python -m debugpy --listen 0.0.0.0:5678 manage.py runserver 0.0.0.0:8000"
#+end_src
Последнюю строчку использовать для отладки приложения.

Запускаем:
#+begin_src sh
docker compose up --build
#+end_src
Идем на http://localhost:8000, там стартовая страничка
Сервер в контейнере ругается на непроведенные миграции. Проводим миграции:
#+begin_src
./sh python manage.py migrate
#+end_src
** Использование
В =./dockerenv= :
 * .env :: в файле нужно указать базовую версию ОС, версию python, каталог проекта, команду запуска в контейнере.
   * =PYTHON_VERSION= : версия python для установки (например, =3.11.10=)
   * =IMAGE= : образ базовой ОС (например, =ubuntu:22.04=)
   * =BUILD_ROOT_SH= : скрипт сборки проекта под root, выполняется в /root контейнера (например, =build.sh=)
   * =BUILD_USER_SH= : скрипт сборки проекта от имени пользователя, выполняется в домашнем каталоге пользователя (например, =""=)
   * =CMD= : команда запуска приложения при старте контейнера (например, ="python manage.py runserver 0.0.0.0:8000"=)
 * compose.yaml :: описывает архитектуру проекта, можно добавить недостающие сервисы в секцию include. Описания стандартных сервисов лежат в каталоге `include`.
** Запуск
Переходим в ./dockerenv в проекте.
 * Запуск контейнера ::
#+begin_src sh
docker compose up --build
#+end_src
Собирается и запускается контейнер dockerenv. Контейнер пересоберется если docker увидел изменения.
 * Пересоздание контейнера ::
   Docker кэширует стадии сборки, если хочется заставить пересоздать контейнер
   #+begin_src
docker compose up --build --force-recreate
   #+end_src
 * Сброс кэша ::
   Хочется всё собранное бросить и начать заново
   #+begin_src
docker builder prune -a
   #+end_src
** Разработка
Внутри dockerenv:
 * ./data :: Здесь лежат постоянные данные между запусками. =.bash_history= , данные redis, БД и проч в соответствующих папках.
 * Подключение из командной строки
 * ./sh :: запуск команды в контейнере. Например, =./sh bash= . =./data/.bash_history= подключается в контейнер, соответственно можно пользоваться отдельной историей bash для проекта.
** Отладка python-приложения
По умолчанию на бэкенде открыт порт 5678, в контейнере его использует [[https://github.com/microsoft/debugpy][debugpy]]. Debugpy работает по протоколу DAP. Чтобы запустить дебаггер, меняем CMD в .env на
#+begin_src sh
CMD="python -m debugpy --listen 0.0.0.0:5678 manage.py runserver 0.0.0.0:8000"
#+end_src
Теперь дебаггер слушает на порту 5678, конфигурация для доступа к нему из vscode в =.vscode/launch.json=.
* Почему так
Исходя из постановки задачи получаем:
1. Базовый image (в отличие от большинства туториалов) берем ubuntu (настраиваемой версии), а не python-minimal. Потому что будем ставить и собирать дополнительные пакеты.
2. В контейнере запускаем проект не от root и разработку ведем не от root, хотя security здесь не проблема. Потому что хотим похожий на привычный для запуска бэкенда подход. Используем uid и имя текущего пользователя.
3. Внутри контейнера изолируем python-проект от ОС. Чтоб управлять версией python и python-пакетами независимо от ОС и дополнительных пакетов.
4. Все порты торчат наружу - для удобства разработки.
5. Запускаем все на одной машине.
6. Пользователь внутри контейнера тот же что снаружи.
7. Считаем что есть requirements.txt в корне проекта.
8. Весь home пользователя в контейнер перекладывать нельзя, поскольку это повлияет на воспроизводимость разработки.
9. Редактирование кода идет снаружи контейнера.
10. Данные, сгенерированные в процессе работы, хранятся в ./data : считаем что даже при пересборке часть внутренних данных нужно сохранить.
* Что потом
 * Сделаль уникальным название контейнера
 * Сделать нормально подключаемым к проекту, как virtualenv или pyenv
 * Дебаг: поправить пути для vscode
 * Как добавить контейнеры для других внутренних микросервисов
 * Логи складывать в общее место
 * Добавить другие сервисы (postgresql, clickhouse, rabbitmq, ...)
 * Для отладки собирать отдельный образ поверх базового
 * Проверить как LSP бегает по коду (в т.ч. библиотек)
 * Добавить шаблон workflow для github и gitlab
 * Сделать отдельную сеть для проекта
 * Придумать как конфигурировать скрипт запуска, чтоб запускать не только Django-проект
 * Сделать шаблоны конфигурации, чтоб не править конфигурационные файлы
 * Разделить установку проекта от рута и без
 * Настроить отладку в Emacs
* Проблемы
 * Отладка в Emacs не работает для Django, работает для скрипта. Работает в  vscode и для Django и для скрипта.
 * docker watch не получилось подключить
 * От порядка строчек в .env зависит запуск контейнера (CMD нельзя ставить первой)
