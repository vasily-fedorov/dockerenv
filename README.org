#+title: Dockerizer

Dockerizing undockerized "not pure python" app

* Что
Изоляция бэкенда большой системы с ее зависимостями от других проектов, сервисов и ОС для разработки.
Это заготовка, скелет для контейнеризации разработки на рабочем месте разработчика: позволяет взять типовой python-проект, поправить конфигурацию и запустить python-проект в виртуальном окружении включая необходимые ему сервисы и пакеты

* Зачем
Хотим получить:
1. Воспроизводимость результатов разработки
2. Отделение devops от разработки
3. Изоляция разработки проекта от окружения

Предлагается принцип "работает == работает в докер-контейнере".

** Изоляция от окружения
Достаточно большой бэкенд для запуска требует сложной настройки, установки и сборки дополнительных пакетов, запуска дополнительных сервисов. Для работы требуются особые зависимости.

Если это какая-то внутренняя сырая разработка, то лежащим рядом с кодом скриптам  запуска нет доверия, они не протестированы как следует: могут делать странные вещи (например, ставить pycharm), работать только на какой-то конкретной ОС конкретной версии (например, "скрипт запуска на Ubuntu 22.04", а у вас Ubuntu 24.04)

В принципе в мире Python есть уже инструменты изоляции разработки от окружения: virtualenv фиксирует отдельные версии пакетов, pyenv позволяет менять версии Python.

Однако остается еще уровень сервисов (postgresql, opensearch, redis, manticore etc) и пакетов - пакеты для конретного проекта (например, простейший https://github.com/django-ve/django-helloworld требует установки дополнительных пакетов), конкретные версии пакетов для работы библиотек, самостоятельная сборка пакетов (GDAL какой-то специальной версии, например).

** Разделение devops и разработчиков
Явно описанная архитектура системы в виде файла compose (docker compose - язык описания архитектуры приложения) позволяет эффективно отделить разработку бэкенда от деплоя: devops понимает как устроен бэкенд, понимает как его запустить, может планировать свой способ деплоя в прод и разрабатывать его в отдельном репозитории.
** Воспроизводимость результатов разработки
Явно прописанная схема сборки упрощает тестирование и онбординг.

* Как
** Быстрый старт
** Запуск
** Разработка
*** data
** Отладка python-приложения
* Почему
Исходя из постановки задачи получаем такие следствия:
1. Базовый image (в отличие от миллиона туториалов) берем ubuntu (настраиваемой версии), а не python-minimal. Потому что будем ставить и собирать дополнительные пакеты.
2. В контейнере запускаем проект не от root и разработку ведем не от root, хотя security здесь не проблема. Потому что хотим похожий на привычный для запуска бэкенда подход.
3. Внутри контейнера изолируем python-проект от ОС. Чтоб управлять версией python и python-пакетами независимо от ОС и дополнительных пакетов.
4. Все порты торчат наружу - для удобства разработки.
5. Запускаем все на одной машине.
6. Пользователь внутри контейнера тот же что снаружи.
7. Считаем что есть requirements.txt в корне проекта.
8. Весь home пользователя в контейнер перекладывать нельзя, поскольку это повлияет на воспроизводимость разработки.
9. Редактирование кода идет снаружи контейнера.
10. Данные, сгенерированные в процессе работы, хранятся в ./data : считаем что даже при пересборке часть внутренних данных нужно сохранить.
* Потом
 * Логи складывать в общее место
 * Добавить другие сервисы (postgresql, clickhouse, rabbitmq, ...)
 * Для отладки собирать отдельный образ поверх базового
 * LSP - как бегать по коду библиотек
* Проблемы
 * Отладка в Emacs не работает, работает в  vscode
 * docker watch не получилось подключить

* Как работает
** Настройки окружения
Лежат в .env:

** Сборка бэкенда
build.sh - запускается на бэкенде для сборки бэкенда
** Постоянные данные
data
 * История bash :: data/bash_history
** Предположения
0. Базовый image не python-minimal, если хватает python-slim, то можно обойтись pyenv. Нужен ubuntu minimal
1. Стандартный python-проект, запускается локально. Хотим чтоб глобально
2. Запускаем все на одной машине
3. security это не проблема и скорость работы тоже, но от рута не запускать
4. requirements.txt в корне проекта
5. Настройка всяких хабов - дело devops по уже готовому проекту
6. Все порты торчат наружу - для удобства разработки
7. Отделить механизмы запуска кода от кода
** Решение
1. Простая контейнеризация python-проекта: скачать репозиторий проекта, скачать репозиторий контейнеризатора, одной командой запустить его в докере
2. Простое подключение других сервисов: БД, celery, redis, nginx, manticore, opensearch, clickhouse,
   (аналогично awesome-compose, инструкциями extends, include, merge)
3. Отдельный от devops привычный dev-репозиторий для разработки на Python с установленными инструментами
   С привычными правилами работы - отладкой, тестированием, профилированием.
4. Логи в одно место со всех подсистем (можно посмотреть на docker logs, но логами надо еще и меняться)
* Детали
1. Запуск не от рута и пробрасывание пользователя в docker
2. Постоянная история bash
3. Установленные инструменты - debugpy? powerline, git, pyenv?
4. Отдельный bind volume для хранения всех постоянных данных - запускаемся на одной машине
* Как дебажить
Внутри поставить debugpy, он
- при запуске debug включает сервер и подключается по pid
- возможно запускает скрипт - тогда ждет клиента
слушает 0.0.0.0:5678

https://github.com/microsoft/debugpy
* Мелочи
5. Нельзя файлы из home прицеплять - для воспроизводимости разработки, точнее прицеплять можно конкретные
6. security - проблема devops, однако не от рута - похоже на локальную разработку
7. Базовый образ - Ubuntu 24.04 LTS, а не "минимальный" образ с Python
* Полезные ссылки
** https://pythonspeed.com/articles/base-image-python-docker-images/
Какой образ python выбирать
** https://docs.docker.com/reference/cli/docker/compose/
cli reference
** https://dev.to/code42cate/say-goodbye-to-docker-volumes-j9l
** https://docs.docker.com/compose/how-tos/file-watch/#compose-watch-versus-bind-mounts
watxh дополняет bind mounts
** https://vsupalov.com/docker-arg-env-variable-guide/
* Docker references
** [[https://github.com/openshift/source-to-image][openshift/source-to-image: A tool for building artifacts from source and injecting into container images]]
Captured On: [2024-12-04 Wed 13:30]
опять про deploy
** [[https://github.com/GoogleContainerTools/jib][GoogleContainerTools/jib: 🏗 Build container images for your Java applications.]]
Captured On: [2024-12-04 Wed 13:29]
Для deploy, опять же
** [[https://emacs-lsp.github.io/lsp-mode/tutorials/docker-integration/][Docker integration - LSP Mode - LSP support for Emacs]]
Captured On: [2024-12-04 Wed 12:41]
Как завернуть дебаггер и lsp в докер
** [[https://saasitive.com/tutorial/django-celery-redis-postgres-docker-compose/][Docker compose with Django 4, Celery, Redis and Postgres | React and Django Tutorial]]
Captured On: [2024-12-04 Wed 11:35]
** TODO [[https://blog.serghei.pl/posts/emacs-python-ide/][Advanced Python Development Workflow in Emacs | Serghei's Blog]]
:LOGBOOK:
- State "TODO"       from              [2024-12-13 Fri 11:44]
:END:
Captured On: [2024-12-12 Thu 14:05]
Крутое руководство по настройке emacs

* Проблема
При включенном watch файл после изменения на хосте получает UID пользователя внутри докера
* Контейнеризация разработки
Не нужен минимальный образ для бэкенда большого приложения

* CANCEL Вариант с devcontainers - то что надо?
** Ссылки на devcontainer
https://github.com/nohzafk/devcontainer-cli-port-forwarder
https://github.com/nohzafk/devcontainer-feature-emacs-lsp-bridge?tab=readme-ov-file
https://github.com/nohzafk/emacs-devcontainer?tab=readme-ov-file
https://github.com/manateelazycat/lsp-bridge?tab=readme-ov-file
** Итого:
1. dev containers это носимые настройки  vscode
2. в докере появились похожие настройки для сборки в новых версиях
3. devfile умер
** Изоляция уже есть в виде

https://frontid.github.io/dockerizer/commands/

compose это язык описания архитектуры приложения
сейчас везде используется как пример для деплоя, хотя есть пример с рисованием картинки:
Это скелет решения, а не готовое решение.
docker init еще есть, но там совсем базовые вещи.
devcontainers - носимые настройки vscode
* О чем это
** Проблема
1. Изоляция devops от разработки
2. Воспроизводимость результатов разработки - "у меня работает".
3. Долгое подключение разработчиков для старта работы

Хочется решить ее за счет принципа "работает == работает в compose"
*Вопрос*: как докеризовать разработку?
** Цель
1. Изоляция кода от архитектуры приложения: postgresql+pgadmin, redis, celery, sentry(?), manticore, clickhouse, opensearch и проч.
2. Изоляция от непитоньих библиотек на бэкенде. (например, хитрые зависимости от GDAL и проч)
3. Изоляция devops от разработки: запускается в compose, значит дальше дело devops донести до прода.
Уже есть слои изоляции - virtualenv, pyenv, но они эти проблемы не решают.
Все туториалы по докеру про запуск питоньего скрипта или про деплой в prod.
