#+title: Dockerizer
Dockerizing undockerized "not pure python" app

* Что это
Изоляция *бэкенда большой системы со сложными зависимостями* от других проектов, сервисов и ОС *для разработки*.
Это заготовка, скелет для контейнеризации разработки на рабочем месте разработчика: позволяет ему взять типовой python-проект, поправить конфигурацию и запустить python-проект в виртуальном окружении включая необходимые ему сервисы и пакеты.

* Зачем это
Хотим получить:
1. Воспроизводимость результатов разработки
2. Отделение devops от разработки
3. Изоляция разработки проекта от окружения

Предлагается принцип /"работает == работает в докер-контейнере"/.

** Изоляция от окружения
Достаточно большой бэкенд для запуска требует сложной настройки, установки и сборки дополнительных пакетов, запуска дополнительных сервисов. Для работы требуются особые зависимости.

Если это какая-то внутренняя сырая разработка, то лежащим рядом с кодом скриптам  запуска нет доверия, они не протестированы как следует: могут делать странные вещи (например, ставить pycharm), работать только на какой-то конкретной ОС конкретной версии (например, "скрипт запуска на Ubuntu 22.04", а у вас Ubuntu 24.04)

В принципе в мире Python есть уже инструменты изоляции разработки от окружения: virtualenv фиксирует отдельные версии пакетов, pyenv позволяет менять версии Python.

Однако остается еще уровень сервисов (postgresql, opensearch, redis, manticore etc) и пакетов - пакеты для конретного проекта (например, простейший https://github.com/django-ve/django-helloworld требует установки дополнительных пакетов), конкретные версии пакетов для работы библиотек, самостоятельная сборка пакетов (GDAL какой-то специальной версии, например).

** Разделение devops и разработчиков
Явно описанная архитектура системы в виде файла compose (docker compose - язык описания архитектуры приложения) позволяет эффективно отделить разработку бэкенда от деплоя: devops понимает как устроен бэкенд, понимает как его запустить, может планировать свой способ деплоя в прод и разрабатывать его в отдельном репозитории.
** Воспроизводимость результатов разработки
Явно прописанная схема сборки упрощает тестирование и онбординг.

* Как это
** Пример
Рассмотрим на примере простого проекта https://github.com/django-ve/django-helloworld .
Находясь в корне нашего проекта:
#+begin_src sh
git clone https://github.com/django-ve/django-helloworld.git
#+end_src
Редактируем .env:
#+begin_src shell
CMD="python manage.py runserver 0.0.0.0:8000"
PROJECT=django-helloworld
PYTHON_VERSION=3.11.10
IMAGE=ubuntu:22.04
#+end_src
Редактируем build.sh, вставляем пакеты из инструкции django-helloworld:
#+begin_src sh
#!/usr/bin/env sh
apt update
apt install -y python3-dev python3-pip python3-virtualenv sqlitebrowser
#+end_src
Запускаем:
#+begin_src sh
docker compose up --build
#+end_src
Идем на http://localhost:8000, там стартовая страничка
** Использование
В подкаталог надо положить докеризуемый проект.
 * .env :: в файле указать базовую версию Ubuntu, версию python, каталог проекта, команду запуска в контейнере.
 * compose.yaml :: описать архитектуру проекта, добавить недостающие сервисы в секцию include. Описания стандартных сервисов лежат в каталоге `include`.
 * build.sh :: команда
** Запуск
 * Запуск контейнера:
#+begin_src sh
docker compose up --build
#+end_src
Собирается и запускается контейнер dockerizer.
** Разработка
 * ./data :: Здесь лежат постоянные данные между запусками. .bash_history , данные redis, БД и проч в соответствующих папках.
 * Подключение из командной строки
 * ./sh :: запуск команды в контейнере. Например, =./sh bash= . =./data/.bash_history= подключается в контейнер, соответственно можно пользоваться отдельной историей bash для проекта.
** Отладка python-приложения
По умолчанию на бэкенде открыт порт 5678, в контейнере его использует [[https://github.com/microsoft/debugpy][debugpy]]. Debugpy работает по протоколу DAP. Чтобы запустить дебаггер, меняем CMD в .env на
#+begin_src sh
CMD="python -m debugpy --listen 0.0.0.0:5678 manage.py runserver 0.0.0.0:8000"
#+end_src
Теперь дебаггер слушает на порту 5678, конфигурация для доступа к нему из vscode в =.vscode/launch.json=.
* Почему
Исходя из постановки задачи получаем:
1. Базовый image (в отличие от большинства туториалов) берем ubuntu (настраиваемой версии), а не python-minimal. Потому что будем ставить и собирать дополнительные пакеты.
2. В контейнере запускаем проект не от root и разработку ведем не от root, хотя security здесь не проблема. Потому что хотим похожий на привычный для запуска бэкенда подход.
3. Внутри контейнера изолируем python-проект от ОС. Чтоб управлять версией python и python-пакетами независимо от ОС и дополнительных пакетов.
4. Все порты торчат наружу - для удобства разработки.
5. Запускаем все на одной машине.
6. Пользователь внутри контейнера тот же что снаружи.
7. Считаем что есть requirements.txt в корне проекта.
8. Весь home пользователя в контейнер перекладывать нельзя, поскольку это повлияет на воспроизводимость разработки.
9. Редактирование кода идет снаружи контейнера.
10. Данные, сгенерированные в процессе работы, хранятся в ./data : считаем что даже при пересборке часть внутренних данных нужно сохранить.
* Потом
 * Сделать подключаемым к проекту, как virtualenv или pyenv
 * Дебаг: поправить пути для vscode
 * Как Добавить контейнеры для других микросервисов
 * Логи складывать в общее место
 * Добавить другие сервисы (postgresql, clickhouse, rabbitmq, ...)
 * Для отладки собирать отдельный образ поверх базового
 * LSP - проверить как бегается по коду библиотек
 * Добавить шаблон workflow для github и gitlab
 * Отдельная сеть для проекта
 * Не только Django-проект - придумать как конфигурировать скрипт запуска
 * Сделать шаблоны конфигурации, чтоб не править конфигурационные файлы
 * Разделить установку проекта от рута и без
 * Настроить отладку в Emacs
* Проблемы
 * Отладка в Emacs не работает для Django, работает для скрипта. Работает в  vscode и для Django и для скрипта.
 * docker watch не получилось подключить

