#+title: Readme
#+setupfile: ~/org/conf/setupfile.org

compose это язык описания архитектуры приложения
сейчас везде используется как пример для деплоя, хотя есть пример с рисованием картинки:
Это скелет решения, а не готовое решение.
docker init еще есть, но там совсем базовые вещи.
devcontainers - носимые настройки vscode
* Как работает
** Настройки окружения
Лежат в .env:

** Сборка бэкенда
build.sh - запускается на бэкенде для сборки бэкенда
** Постоянные данные
data
 * История bash :: data/bash_history
* О чем это
** Проблема
1. Долгое подключение разработчиков для старта работы
2. Воспроизводимость результатов разработки - "у меня работает".
3. Изоляция devops от разработки

Хочется решить ее за счет принципа "работает == работает в compose"
*Вопрос*: как докеризовать разработку?
** Цель
1. Изоляция кода от архитектуры приложения: postgresql+pgadmin, redis, celery, sentry(?), manticore, clickhouse, opensearch и проч.
2. Изоляция от непитоньих библиотек на бэкенде. (например, хитрые зависимости от GDAL и проч)
3. Изоляция devops от разработки: запускается в compose, значит дальше дело devops донести до прода.
Уже есть слои изоляции - virtualenv, pyenv, но они эти проблемы не решают.
Все туториалы по докеру про запуск питоньего скрипта или про деплой в prod.
** Предположения
1. Стандартный python-проект, запускается локально. Хотим чтоб глобально
2. Запускаем все на одной машине
3. security это не проблема и скорость работы
4. requirements.txt в корне проекта
5. Настройка всяких хабов - дело devops по уже готовому проекту
6. Все порты торчат наружу - для удобства разработки
7. Отделить механизмы запуска кода от кода
** Решение
1. Простая контейнеризация python-проекта: скачать репозиторий проекта, скачать репозиторий контейнеризатора, одной командой запустить его в докере
2. Простое подключение других сервисов: БД, celery, redis, nginx, manticore, opensearch, clickhouse,
   (аналогично awesome-compose, инструкциями extends, include, merge)
3. Отдельный от devops привычный dev-репозиторий для разработки на Python с установленными инструментами
   С привычными правилами работы - отладкой, тестированием, профилированием.
4. Логи в одно место со всех подсистем (можно посмотреть на docker logs, но логами надо еще и меняться)
* Детали
1. Запуск не от рута и пробрасывание пользователя в docker
2. Постоянная история bash
3. Установленные инструменты - debugpy? powerline, git, pyenv?
4. Отдельный bind volume для хранения всех постоянных данных - запускаемся на одной машине
* Мелочи
5. Нельзя файлы из home прицеплять - для воспроизводимости разработки, точнее прицеплять можно конкретные
6. security - проблема devops, однако не от рута - похоже на локальную разработку
7. Базовый образ - Ubuntu 24.04 LTS, а не "минимальный" образ с Python
* Полезные ссылки
** https://pythonspeed.com/articles/base-image-python-docker-images/
Какой образ python выбирать
** https://docs.docker.com/reference/cli/docker/compose/
cli reference
** https://dev.to/code42cate/say-goodbye-to-docker-volumes-j9l
** https://docs.docker.com/compose/how-tos/file-watch/#compose-watch-versus-bind-mounts
watxh дополняет bind mounts
** https://vsupalov.com/docker-arg-env-variable-guide/
* Проблема
При включенном watch файл после изменения на хосте получает UID пользователя внутри докера
* Контейнеризация разработки
Не нужен минимальный образ для бэкенда большого приложения

* CANCEL Вариант с devcontainers - то что надо?
** Ссылки на devcontainer
https://github.com/nohzafk/devcontainer-cli-port-forwarder
https://github.com/nohzafk/devcontainer-feature-emacs-lsp-bridge?tab=readme-ov-file
https://github.com/nohzafk/emacs-devcontainer?tab=readme-ov-file
https://github.com/manateelazycat/lsp-bridge?tab=readme-ov-file
** Итого:
1. dev containers это носимые настройки  vscode
2. в докере появились похожие настройки для сборки в новых версиях
3. devfile умер
